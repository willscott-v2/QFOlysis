import { NextRequest, NextResponse } from 'next/server';
import { type AnalysisResult } from '../../lib/types';

interface ExportRequest {
  analysisData: AnalysisResult;
  format: 'csv' | 'json' | 'txt';
  options: {
    includeRawData: boolean;
    includeMetadata: boolean;
  };
}

export async function POST(request: NextRequest) {
  try {
    const body: ExportRequest = await request.json();
    const { analysisData, format, options } = body;

    if (!analysisData) {
      return NextResponse.json(
        { error: 'Analysis data is required' },
        { status: 400 }
      );
    }

    let content: string;
    let filename: string;
    let contentType: string;

    if (format === 'csv') {
      content = convertToCSV(analysisData, options);
      filename = `qfolysis-analysis-${analysisData.analysisId}.csv`;
      contentType = 'text/csv';
    } else if (format === 'json') {
      content = JSON.stringify(convertToJSON(analysisData, options), null, 2);
      filename = `qfolysis-analysis-${analysisData.analysisId}.json`;
      contentType = 'application/json';
    } else if (format === 'txt' || format === 'markdown') {
      content = convertToMarkdown(analysisData, options);
      const date = new Date(analysisData.timestamp);
      const dateStr = date.toISOString().slice(0, 10);
      const timeStr = date.toISOString().slice(11, 19).replace(/:/g, '-');
      const domain = new URL(analysisData.targetUrl).hostname.replace('www.', '').split('.')[0];
      const titleCaseDomain = domain.charAt(0).toUpperCase() + domain.slice(1);
      
      filename = `QFOlysis AI Readiness Report For ${titleCaseDomain} - ${analysisData.analysisId} - ${dateStr} At ${timeStr}.md`;
      contentType = 'text/markdown';
    } else {
      return NextResponse.json(
        { error: 'Unsupported export format' },
        { status: 400 }
      );
    }

    return new NextResponse(content, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
    });

  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json(
      { error: 'Failed to export data' },
      { status: 500 }
    );
  }
}

function convertToMarkdown(analysis: AnalysisResult, options: any): string {
  const date = new Date(analysis.timestamp);
  const formattedDate = date.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  const formattedTime = date.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    timeZoneName: 'short'
  });
  
  const targetDomain = new URL(analysis.targetUrl).hostname.replace('www.', '');
  
  return `# QFOlysis AI Readiness Assistant - Analysis Report For ${targetDomain.split('.').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('.')} - ${formattedDate} At ${formattedTime}

**Analysis ID:** ${analysis.analysisId}  
**Date:** ${formattedDate}  
**Time:** ${formattedTime}  
**Target URL:** ${analysis.targetUrl}

## AI Readiness Executive Summary

Your content scored **${analysis.targetScore}/100** for AI readiness compared to an average competitor score of **${Math.round(analysis.competitorResults.reduce((sum, c) => sum + c.overallScore, 0) / Math.max(analysis.competitorResults.length, 1))}/100**.

## Performance by Category

${analysis.radarData.map(category => `
### ${category.category}
- **Your Score:** ${category.targetScore}/100
- **Competitor Average:** ${category.competitorAvg}/100
- **Gap:** ${category.targetScore - category.competitorAvg > 0 ? '+' : ''}${category.targetScore - category.competitorAvg} points
`).join('')}

## Content Gaps & Opportunities

${analysis.coverageGaps.length > 0 ? analysis.coverageGaps.map(gap => `
### ${gap.category} (${gap.priority.toUpperCase()} Priority)

**Recommendation:** ${gap.recommendation}

**Missing Topics:**
${gap.missingQueries.map(q => `- ${q}`).join('\n')}

**Learn from competitors:**
${gap.competitorUrls.map(url => `- ${url}`).join('\n')}
`).join('') : 'No significant content gaps identified. Your content performs well across all analyzed categories.'}

## AI Recommendations

${analysis.recommendations.map((rec, i) => `${i + 1}. ${rec}`).join('\n')}

## Analysis Details

- **Analysis ID:** ${analysis.analysisId}
- **Total Queries Analyzed:** ${analysis.queries.length}
- **Competitors Analyzed:** ${analysis.competitorResults.length}
- **Processing Time:** ${analysis.processingTime}ms

---
*Generated by QFOlysis AI Readiness Assistant*`;
}

function convertToCSV(analysisData: AnalysisResult, options: ExportRequest['options']): string {
  const headers = [
    'URL',
    'Title',
    'Overall Score',
    'Category',
    'Category Score',
    'Matched Queries',
    'Total Queries',
    'Recommendations',
  ];

  const rows: string[][] = [headers];

  // Add target data
  rows.push([
    analysisData.targetUrl,
    analysisData.targetTitle,
    analysisData.targetScore.toString(),
    'Overall',
    analysisData.targetScore.toString(),
    analysisData.queries.length.toString(),
    analysisData.queries.length.toString(),
    analysisData.recommendations.join('; '),
  ]);

  // Add category scores for target
  for (const categoryScore of analysisData.radarData) {
    rows.push([
      analysisData.targetUrl,
      analysisData.targetTitle,
      analysisData.targetScore.toString(),
      categoryScore.category,
      categoryScore.targetScore.toString(),
      '', // Matched queries - would need to calculate
      '', // Total queries - would need to calculate
      '', // Recommendations
    ]);
  }

  // Add competitor data
  for (const competitor of analysisData.competitorResults) {
    rows.push([
      competitor.url,
      competitor.title,
      competitor.overallScore.toString(),
      'Overall',
      competitor.overallScore.toString(),
      competitor.topQueries.length.toString(),
      analysisData.queries.length.toString(),
      competitor.recommendations.join('; '),
    ]);

    // Add category scores for competitor
    for (const categoryScore of competitor.categoryScores) {
      rows.push([
        competitor.url,
        competitor.title,
        competitor.overallScore.toString(),
        categoryScore.category,
        categoryScore.score.toString(),
        categoryScore.matchedQueries.toString(),
        categoryScore.totalQueries.toString(),
        '', // Recommendations
      ]);
    }
  }

  return rows.map(row => 
    row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
  ).join('\n');
}

function convertToJSON(analysisData: AnalysisResult, options: ExportRequest['options']): any {
  const exportData: any = {
    metadata: {
      analysisId: analysisData.analysisId,
      targetUrl: analysisData.targetUrl,
      timestamp: analysisData.timestamp,
      processingTime: analysisData.processingTime,
    },
    target: {
      url: analysisData.targetUrl,
      title: analysisData.targetTitle,
      overallScore: analysisData.targetScore,
      categoryScores: analysisData.radarData.map(data => ({
        category: data.category,
        score: data.targetScore,
        maxScore: data.maxScore,
      })),
    },
    competitors: analysisData.competitorResults.map(competitor => ({
      url: competitor.url,
      title: competitor.title,
      overallScore: competitor.overallScore,
      categoryScores: competitor.categoryScores,
      topQueries: competitor.topQueries,
      recommendations: competitor.recommendations,
    })),
    analysis: {
      queries: analysisData.queries,
      coverageGaps: analysisData.coverageGaps,
      recommendations: analysisData.recommendations,
      radarData: analysisData.radarData,
    },
  };

  if (options.includeRawData) {
    exportData.rawData = {
      queries: analysisData.queries,
      radarData: analysisData.radarData,
      coverageGaps: analysisData.coverageGaps,
    };
  }

  return exportData;
} 